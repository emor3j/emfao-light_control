name: Build and Release Firmware

on:
  push:
    tags:
      - 'v*.*'  # Trigger on version tags like v1.0
  workflow_dispatch:  # Allow manual trigger
    inputs:
      version:
        description: 'Release version (e.g., v1.0)'
        required: true
        default: 'v1.0'

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        
    - name: Cache pip packages
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    - name: Install PlatformIO
      run: |
        python -m pip install --upgrade pip
        pip install platformio
        
    - name: Install PlatformIO dependencies
      run: pio pkg install
      
    - name: Build firmware
      run: pio run --environment esp32dev
      
    - name: Build filesystem
      run: pio run --target buildfs --environment esp32dev
      
    - name: Get version
      id: version
      run: |
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          VERSION="${{ github.event.inputs.version }}"
        else
          VERSION=${GITHUB_REF#refs/tags/}
        fi
        echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
        echo "Building version: ${VERSION}"
        
    - name: Create merged firmware
      run: |
        # Install esptool if not available
        pip install esptool
        
        # Create release directory
        mkdir -p release
        
        # Copy individual binaries
        cp .pio/build/esp32dev/firmware.bin release/
        cp .pio/build/esp32dev/littlefs.bin release/ || echo "No filesystem image found"
        
        # Get ESP32 boot files from PlatformIO
        FRAMEWORK_DIR=$(pio system info | grep "PlatformIO Core" -A 20 | grep "esp32" | head -1 | awk '{print $2}')
        if [ -z "$FRAMEWORK_DIR" ]; then
          FRAMEWORK_DIR="~/.platformio/packages/framework-arduinoespressif32"
        fi
        
        # Try to find bootloader and partition files
        BOOTLOADER_FILE=""
        PARTITIONS_FILE=""
        BOOT_APP_FILE=""
        
        # Common locations for ESP32 bootloader
        for path in \
          "~/.platformio/packages/framework-arduinoespressif32/tools/sdk/esp32/bin/bootloader_dio_40m.bin" \
          "~/.platformio/packages/framework-arduinoespressif32/tools/sdk/bin/bootloader_dio_40m.bin" \
          ".pio/build/esp32dev/bootloader.bin"; do
          if [ -f "$path" ]; then
            BOOTLOADER_FILE="$path"
            break
          fi
        done
        
        # Find partition table
        for path in \
          ".pio/build/esp32dev/partitions.bin" \
          "~/.platformio/packages/framework-arduinoespressif32/tools/partitions/default.bin"; do
          if [ -f "$path" ]; then
            PARTITIONS_FILE="$path"
            break
          fi
        done
        
        # Find boot_app0
        for path in \
          "~/.platformio/packages/framework-arduinoespressif32/tools/sdk/esp32/bin/boot_app0.bin" \
          "~/.platformio/packages/framework-arduinoespressif32/tools/sdk/bin/boot_app0.bin" \
          ".pio/build/esp32dev/boot_app0.bin"; do
          if [ -f "$path" ]; then
            BOOT_APP_FILE="$path"
            break
          fi
        done
        
        # Create individual files for advanced users
        if [ -f "$BOOTLOADER_FILE" ]; then
          cp "$BOOTLOADER_FILE" release/bootloader.bin
        fi
        if [ -f "$PARTITIONS_FILE" ]; then
          cp "$PARTITIONS_FILE" release/partitions.bin  
        fi
        if [ -f "$BOOT_APP_FILE" ]; then
          cp "$BOOT_APP_FILE" release/boot_app0.bin
        fi
        
        # Create merged binary with all components
        echo "Creating merged firmware binary..."
        
        MERGE_CMD="esptool.py --chip esp32 merge_bin -o release/emfao-light-control-${{ steps.version.outputs.VERSION }}-merged.bin --flash_mode dio --flash_freq 40m --flash_size 4MB"
        
        # Add bootloader if found
        if [ -f "$BOOTLOADER_FILE" ]; then
          MERGE_CMD="$MERGE_CMD 0x1000 $BOOTLOADER_FILE"
        fi
        
        # Add partition table if found  
        if [ -f "$PARTITIONS_FILE" ]; then
          MERGE_CMD="$MERGE_CMD 0x8000 $PARTITIONS_FILE"
        fi
        
        # Add boot_app0 if found
        if [ -f "$BOOT_APP_FILE" ]; then
          MERGE_CMD="$MERGE_CMD 0xe000 $BOOT_APP_FILE"  
        fi
        
        # Add main firmware
        MERGE_CMD="$MERGE_CMD 0x10000 .pio/build/esp32dev/firmware.bin"
        
        # Add filesystem if exists
        if [ -f ".pio/build/esp32dev/littlefs.bin" ]; then
          # LittleFS typically goes at a high address, we'll use a common default
          MERGE_CMD="$MERGE_CMD 0x290000 .pio/build/esp32dev/littlefs.bin"
        fi
        
        # Execute merge command
        eval $MERGE_CMD
        
        # Verify the merged binary was created
        if [ -f "release/emfao-light-control-${{ steps.version.outputs.VERSION }}-merged.bin" ]; then
          echo "âœ… Merged firmware created successfully"
          ls -la release/emfao-light-control-${{ steps.version.outputs.VERSION }}-merged.bin
        else
          echo "âŒ Failed to create merged firmware"
          exit 1
        fi
        
    - name: Create flash scripts
      run: |
        # Create Windows batch script
        cat > release/flash-windows.bat << 'EOF'
        @echo off
        echo EMFAO Light Control - ESP32 Flash Tool
        echo =====================================
        echo.
        echo Make sure your ESP32 is connected via USB and in download mode:
        echo 1. Hold BOOT button
        echo 2. Press and release RESET button  
        echo 3. Release BOOT button
        echo.
        pause
        
        echo Detecting COM port...
        for /f "tokens=*" %%i in ('python -m serial.tools.list_ports -q') do set COMPORT=%%i
        if "%COMPORT%"=="" (
            echo No COM port detected. Please check your ESP32 connection.
            pause
            exit /b 1
        )
        
        echo Using COM port: %COMPORT%
        echo.
        echo Flashing firmware...
        python -m esptool --chip esp32 --port %COMPORT% --baud 460800 write_flash 0x0 emfao-light-control-${{ steps.version.outputs.VERSION }}-merged.bin
        
        if %ERRORLEVEL% EQU 0 (
            echo.
            echo âœ… Flashing completed successfully!
            echo Your ESP32 will now reboot with the new firmware.
        ) else (
            echo.
            echo âŒ Flashing failed. Please check your connection and try again.
        )
        
        pause
        EOF
        
        # Create Linux/Mac script
        cat > release/flash-unix.sh << 'EOF'
        #!/bin/bash
        
        echo "EMFAO Light Control - ESP32 Flash Tool"
        echo "====================================="
        echo
        echo "Make sure your ESP32 is connected via USB and in download mode:"
        echo "1. Hold BOOT button"
        echo "2. Press and release RESET button"
        echo "3. Release BOOT button"
        echo
        read -p "Press Enter when ready..."
        
        # Try to detect the port
        PORT=""
        if [ -e /dev/ttyUSB0 ]; then
            PORT="/dev/ttyUSB0"
        elif [ -e /dev/ttyACM0 ]; then
            PORT="/dev/ttyACM0" 
        elif ls /dev/cu.usbserial* 1> /dev/null 2>&1; then
            PORT=$(ls /dev/cu.usbserial* | head -1)
        elif ls /dev/cu.SLAB_USBtoUART* 1> /dev/null 2>&1; then
            PORT=$(ls /dev/cu.SLAB_USBtoUART* | head -1)
        fi
        
        if [ -z "$PORT" ]; then
            echo "Could not detect ESP32 port automatically."
            read -p "Please enter the port manually (e.g., /dev/ttyUSB0): " PORT
        fi
        
        echo "Using port: $PORT"
        echo
        echo "Flashing firmware..."
        
        python3 -m esptool --chip esp32 --port "$PORT" --baud 460800 write_flash 0x0 emfao-light-control-${{ steps.version.outputs.VERSION }}-merged.bin
        
        if [ $? -eq 0 ]; then
            echo
            echo "âœ… Flashing completed successfully!"
            echo "Your ESP32 will now reboot with the new firmware."
        else
            echo
            echo "âŒ Flashing failed. Please check your connection and try again."
        fi
        
        read -p "Press Enter to exit..."
        EOF
        
        chmod +x release/flash-unix.sh
        
    - name: Create documentation
      run: |
        cat > release/FLASH_INSTRUCTIONS.md << 'EOF'
        # EMFAO Light Control - Flash Instructions
        
        ## Quick Start
        
        ### Option 1: Automatic Flash (Recommended)
        
        **Windows:**
        1. Install Python: https://python.org/downloads/
        2. Install esptool: `pip install esptool`
        3. Connect your ESP32 via USB
        4. Double-click `flash-windows.bat`
        5. Follow the on-screen instructions
        
        **Linux/macOS:**
        1. Install Python: `sudo apt install python3-pip` (Ubuntu) or `brew install python3` (macOS)
        2. Install esptool: `pip3 install esptool`
        3. Connect your ESP32 via USB
        4. Run: `./flash-unix.sh`
        5. Follow the on-screen instructions
        
        ### Option 2: Manual Flash
        
        If the automatic scripts don't work, use this manual command:
        
        ```bash
        esptool.py --chip esp32 --port [YOUR_PORT] --baud 460800 write_flash 0x0 emfao-light-control-${{ steps.version.outputs.VERSION }}-merged.bin
        ```
        
        Replace `[YOUR_PORT]` with:
        - **Windows**: `COM3`, `COM4`, etc.
        - **Linux**: `/dev/ttyUSB0`, `/dev/ttyACM0`, etc.  
        - **macOS**: `/dev/cu.usbserial-*` or `/dev/cu.SLAB_USBtoUART`
        
        ## Putting ESP32 in Download Mode
        
        1. **Hold** the BOOT button (sometimes labeled FLASH)
        2. **Press and release** the RESET button (sometimes labeled EN)
        3. **Release** the BOOT button
        4. The ESP32 is now ready for flashing
        
        ## After Flashing
        
        1. **Press the RESET button** or unplug/replug the USB cable
        2. **Connect to WiFi**: Look for "emfao-LedControler" access point (password=12345678)
        3. **Configure**: Go to http://192.168.4.1 to set up your WiFi
        4. **Access**: Once connected, find the ESP32's IP and access the web interface
        
        ## Troubleshooting
        
        **"Failed to connect":**
        - Check USB cable (needs data, not just power)
        - Try different USB port
        - Make sure ESP32 is in download mode
        - Check if drivers are installed (CP210x or CH340 drivers)
        
        **"Permission denied" (Linux/macOS):**
        ```bash
        sudo usermod -a -G dialout $USER
        # Then logout and login again
        ```
        
        **Still not working?**
        - Try lower baud rate: change `460800` to `115200` in commands
        - Use ESP32 Flash Download Tool: https://www.espressif.com/en/support/download/other-tools
        
        ## Hardware Requirements
        
        - ESP32 development board
        - PCA9685 PWM driver module(s)
        - LEDs connected to PCA9685 outputs
        - I2C connections (SDA/SCL) between ESP32 and PCA9685
        
        ## Default Configuration
        
        - **I2C SDA**: GPIO 21
        - **I2C SCL**: GPIO 22
        - **Web Interface**: http://[ESP32_IP]/
        - **Default AP**: EMFAO-Config (no password)
        
        ---
        
        For support and documentation: https://github.com/emor3j/emfao-light_control
        EOF
        
    - name: Create release package
      run: |
        cd release
        
        # Create version info file
        cat > VERSION.txt << EOF
        EMFAO Light Control Firmware
        Version: ${{ steps.version.outputs.VERSION }}
        Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        Git Commit: ${{ github.sha }}
        
        Components:
        - ESP32 firmware with LED animation programs
        - Web interface for configuration
        - WiFi setup and OTA updates
        - PCA9685 PWM driver support
        EOF
        
        # List all files
        echo "ðŸ“¦ Release package contents:"
        ls -la
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: emfao-light-control-${{ steps.version.outputs.VERSION }}
        path: release/
        retention-days: 30
        
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      if: startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch'
      with:
        tag_name: ${{ steps.version.outputs.VERSION }}
        name: EMFAO Light Control ${{ steps.version.outputs.VERSION }}
        body: |
          ## ðŸš€ EMFAO Light Control ${{ steps.version.outputs.VERSION }}
          
          ESP32 LED controller with animated lighting programs for model railways.
          
          ### ðŸ“¦ What's included:
          - **emfao-light-control-${{ steps.version.outputs.VERSION }}-merged.bin** - Complete firmware (flash this!)
          - **flash-windows.bat** - Windows flash script
          - **flash-unix.sh** - Linux/macOS flash script  
          - **FLASH_INSTRUCTIONS.md** - Detailed flashing guide
          - Individual binary files for advanced users
          
          ### âš¡ Quick Flash:
          1. Download and extract the release
          2. Connect ESP32 via USB
          3. Run the flash script for your OS
          4. Follow the instructions
          
          ### ðŸŽ¯ Features in this release:
          - 8 LED animation programs
          - Web-based configuration interface
          - WiFi setup with captive portal
          - OTA firmware updates
          - Multi-PCA9685 support
          - Persistent configuration storage
          
          ### ðŸ“– Full instructions: 
          See `FLASH_INSTRUCTIONS.md` in the download
          
          ---
          
          **Build Info:**
          - Commit: ${{ github.sha }}
          - Built: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        files: |
          release/*
        draft: false
        prerelease: false
        token: ${{ secrets.GITHUB_TOKEN }}